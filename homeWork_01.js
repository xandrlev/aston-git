/*
1) Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.

- Метод запроса OPTIONS является одним из HTTP-методов и предназначен для получения информации о возможностях сервера или характеристиках ресурса,
  без выполнения запроса.
- OPTIONS-запрос может быть отправлен клиентом для определения доступных методов запроса (например, GET, POST) и других характеристик сервера или ресурса.
- OPTIONS-запросы широко применяются в контексте кросс-доменных запросов (CORS). Браузеры отправляют OPTIONS-запросы на другой домен,
  чтобы определить, разрешены ли конкретные типы запросов.
- Запрос OPTIONS не содержит тела, но может включать заголовки, например, для указания определенных параметров запроса.
  В ответ сервер может включать заголовки, описывающие поддерживаемые методы запроса, поддерживаемые заголовки и т.д.


2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0

- Новая версия HTTP протокола, разработаная поверх QUIC - мультиплексированный шифрованный транспортный протокол
  построенный на UDP.
- Поддерживает мультиплексирование, что позволяет одному соединению одновременно передавать несколько потоков данных.
- Стремится устранить проблему блокировки потоков данных, что улучшает производительность.
- Предоставляет более эффективный механизм обработки ошибок.
- Уменьшает задержку при соединении и адаптируется к изменениям качества соединени.

3) Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать)
  (string, number, boolean, null, undefined, symbol, bigInt)
*/

const numValue1 = Number.parseInt("3.14");
const numValue2 = ~~(Math.random() * 10);
const numValue3 = numValue1 + Infinity;
console.log(`Number:`, typeof numValue3);

const strValue1 = "Hello";
const strValue2 = String("World");
const strValue3 = `${strValue1} ${strValue2}`;
console.log(`String:`, strValue3);

const booleanValue1 = !!{};
const booleanValue2 = Boolean(0 && []);
const booleanValue3 = Math.max() < Math.min();
console.log(`Boolean:`, booleanValue3);

const nullValue1 = null;
const nullValue2 = undefined ?? null;
console.log(`null:`, nullValue2);

let undefinedValue1;
const undefinedValue2 = void 5;
console.log(`undefined:`, undefinedValue2);

const symbolValue1 = Symbol();
const symbolValue2 = Symbol("foo");
console.log(`Symbol:`, symbolValue2);

const bigIntlValue1 = 123n;
const bigIntlValue2 = BigInt("12345678901234567890");
console.log(`bigInt:`, bigIntlValue2);

/*
4) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?

  - Переменные, объявленые при помощи директивы let и const тоже "всплывают" hoisting. Но в отличии от var
  мы не можем получить доступ к ним до выполнения фактического определения в run-time.
  Чтобы этого избежать  следует инициализировать их перед обращением к ним.

  5) Решить:
*/

const res = "B" + "a" + (1 - "hello");
console.log(res); //BaNaN
// При выполнении математических операций (- , *, /) string и других типов результатом будет NaN
// Следующим шагом идёт конкатенация строк. (Из-за приведения типов к строке).

const res2 = (true && 3) + "d";
console.log(res2); //3d
// Оператор && является логическим оператором "И", используется для комбинирования двух условий.
// Он возвращает true, если оба операнда истинны, и false в противном случае. (В данном случае 3)
// Следующим шагом идёт конкатенация строк. (Из-за приведения типов к строке).

const res3 = Boolean(true && 3) + "d";
console.log(res3); //trued
// В данном сдучае Boolean вернёт true.
// Следующим шагом идёт конкатенация строк. (Из-за приведения типов к строке).
